111.二叉树最小深度
class Solution {
public:
    int minDepth(TreeNode* root) {
         if(root == nullptr) {
            return 0;
        }

        int leftdepth = minDepth(root -> left);
        int rightdepth = minDepth(root -> right);

        if(root -> left == nullptr) {
            return rightdepth + 1;
        }

        if(root -> right == nullptr) {
            return leftdepth + 1;
        }

        if(leftdepth <= rightdepth) {
            return leftdepth + 1;
        } else {
            return rightdepth + 1;
        }
    }
};
时间复杂度：O(n)
先判断当前节点是不是空，如果是那么深度为0
用递归查找左子树和右子树的深度，如果某一侧子树为空，则返回另一侧子树深度
对比左右子树深度，返回更小的深度+1

112.路径总和
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) {
            return false;
        }

        targetSum -= root -> val;

        if(root -> left == nullptr && root -> right == nullptr) {
            return targetSum == 0;
        }

        return hasPathSum(root -> left, targetSum) || hasPathSum(root -> right, targetSum);
    }
};
时间复杂度：O(n)
先判断最初节点是不是空，如果是空那么不可能有满足目标总和的路径，返回false
target减去当前节点的value，改变target值，然后检查当前节点是不是叶子节点；
如果是且满足target已经被减到0，则返回true
如果不是叶子节点，用递归继续向下查找直到找到叶子节点

119.杨辉三角2
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> ans(rowIndex + 1, 0);
        ans[0] = 1;
        for(int i = 1; i <= rowIndex; i++) {
            for(int j = i; j >= 1; j--) {
                ans[j] = ans[j] + ans[j - 1];
            }
        }
        return ans;
    }
};
时间复杂度：O(n^2)
先规定一个ans数组，规定0位置数值为1
从第一行遍历到rowIndex行，从最后一个元素开始，根据杨辉三角规则向前更新当前行的数值
不能使用正向遍历是因为正向会覆盖上一行的值
最后返回ans数组

136.只出现一次的数字
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i += 2) {
            if (i == nums.size() - 1 || nums[i] != nums[i + 1]) {
                return nums[i];
            }
        }return -1;
    }
};
时间复杂度：O(n)
对nums数组排序，从第一个数字开始遍历整个数组，如果当前数字与下一个数字不相同，
或是数组的最后一个，则返回当前数字
我看到解析里提到用异或，但没太懂